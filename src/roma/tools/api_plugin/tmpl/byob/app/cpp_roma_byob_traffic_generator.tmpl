/**
 * This file is @generated by
 * src/roma/tools/api_plugin/tmpl/byob/app/cpp_roma_byob_traffic_generator.tmpl.
 * Do not edit.
 * Version: {{getVersion}}
 * Code Generator: {{getRomaGenerator}}
*/

/**
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{{$file := index .Files 0}}
#include "{{$file.Name | trimSuffix (ext $file.Name)}}_roma_byob_app_service.h"

#include <fstream>
#include <string>
#include <string_view>

#include "absl/flags/flag.h"
#include "absl/flags/parse.h"
#include "absl/log/check.h"
#include "absl/log/initialize.h"
#include "absl/log/log.h"
#include "absl/log/globals.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/match.h"
#include "absl/synchronization/notification.h"
#include "google/protobuf/text_format.h"
#include "src/communication/json_utils.h"
#include "src/roma/byob/benchmark/burst_generator.h"
#include "src/roma/byob/config/config.h"
#include "src/util/periodic_closure.h"

ABSL_FLAG(std::string, udf, "", "the UDF executable to be benchmarked");
// TODO(b/391407327): Use enum to specify the list of valid rpc names.
ABSL_FLAG(std::string, rpc, "", "the name of the rpc method to invoke");
ABSL_FLAG(std::string, request, "",
          "the file for the UDF request, in json or text proto format");
ABSL_FLAG(::privacy_sandbox::server_common::byob::Mode, sandbox_mode,
          ::privacy_sandbox::server_common::byob::Mode::kModeGvisorSandbox,
          "BYOB sandboxing mode");
ABSL_FLAG(int, num_workers, 1, "number of workers");
ABSL_FLAG(int, num_queries, 10'000, "number of queries to be sent");
ABSL_FLAG(int, burst_size, 14,
          "number of times to execute for a single query");
ABSL_FLAG(int, queries_per_second, 42,
          "number of queries to be sent in a second");

{{$svc := index $file.Services 0}}
{{- $svcopts := index $svc.Options "privacysandbox.apis.roma.app_api.v1.roma_svc_annotation"}}
{{- $svcName := printf "Byob%s" $svc.Name -}}
namespace {
using {{$svcopts.CppNamespace}}::{{$svcName}};

std::string LoadImpl({{$svcName}}<>& roma_service, std::string_view udf,
                     int num_workers) {
  absl::StatusOr<std::string> code_id =
      roma_service.Register(udf, num_workers);
  CHECK_OK(code_id);
  return *std::move(code_id);
}
{{- range $rpc := $svc.MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation"}}
  {{- $pkg := $svcopts.CppNamespace | replace "." "::" | printf "::%s" }}
  {{- $reqType := $rpc.RequestType | replace "." "::" | printf "%s::%s" $pkg }}
  {{- $respType := $rpc.ResponseType | replace "." "::" | printf "%s::%s" $pkg }}
void {{$rpc.Name}}ExecuteImpl(
    {{$svcName}}<>& roma_service,
    std::string_view code_token,
    std::atomic_int& completions,
    privacy_sandbox::server_common::Stopwatch stopwatch,
    absl::StatusOr<absl::Duration>& duration,
    const {{$reqType}}& request) {
  const auto execution_token = roma_service.{{$rpc.Name}}(
      [&, stopwatch = std::move(stopwatch)] (auto response) {
        if (response.ok()) {
          duration = stopwatch.GetElapsedTime();
        } else {
          duration = std::move(response).status();
        }
        completions++;
      },
      request, /*metadata=*/{}, code_token);
  if (!execution_token.ok()) {
    duration = std::move(execution_token).status();
    completions++;
  }
}
{{end}}
void RunTrafficGenerator() {
  const int num_workers = absl::GetFlag(FLAGS_num_workers);
  CHECK_GT(num_workers, 0) << "missing --num_workers flag";
  const std::string udf = absl::GetFlag(FLAGS_udf);
  const std::string rpc = absl::GetFlag(FLAGS_rpc);
  bool is_json = false;
  const std::string request_content = [&] {
    const std::string request = absl::GetFlag(FLAGS_request);
    is_json = absl::EndsWith(request, ".json");
    CHECK(is_json || absl::EndsWith(request, ".txtpb")) << "request must be a .json or .txtpb file";
    std::ifstream ifs(request);
    CHECK(ifs.is_open()) << "Unable to open '" << request << "'";
    return std::string(std::istreambuf_iterator<char>(ifs),
                       std::istreambuf_iterator<char>());
  }();
  const int num_queries = absl::GetFlag(FLAGS_num_queries);
  CHECK_GT(num_queries, 0);
  const int burst_size = absl::GetFlag(FLAGS_burst_size);
  CHECK_GT(burst_size, 0);
  const int expected_completions = num_queries * burst_size;
  std::atomic_int completions = 0;
  auto periodic = ::privacy_sandbox::server_common::PeriodicClosure::Create();
  if (absl::Status status = periodic->StartDelayed(
          absl::Seconds(1),
          [&completions, expected_completions]() {
            static int previous = 0;
            const int curr_val = completions;
            if (previous != expected_completions) {
              LOG(INFO) << "completions: " << curr_val
                        << ", increment: " << curr_val - previous;
            }
            previous = curr_val;
          });
      !status.ok()) {
    LOG(FATAL) << status;
  }
  const int queries_per_second = absl::GetFlag(FLAGS_queries_per_second);
  CHECK_GT(queries_per_second, 0);
  using ::privacy_sandbox::server_common::byob::BurstGenerator;
  const absl::Duration burst_cadence = absl::Seconds(1) / queries_per_second;
  absl::StatusOr<{{$svcName}}<>> roma_service =
      {{$svcName}}<>::Create(/*config=*/{}, absl::GetFlag(FLAGS_sandbox_mode));
  CHECK_OK(roma_service);
{{- range $rpc := $svc.MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation"}}
  {{- $pkg := $svcopts.CppNamespace | replace "." "::" | printf "::%s" }}
  {{- $reqType := $rpc.RequestType | replace "." "::" | printf "%s::%s" $pkg }}
  if (rpc == "{{$rpc.Name}}") {
    const std::string code_token = LoadImpl(*roma_service, udf, num_workers);
    absl::StatusOr<{{$reqType}}> request;
    if (is_json) {
      request = ::privacy_sandbox::server_common::JsonToProto<{{$reqType}}>(
                          request_content);
      CHECK_OK(request);
    } else {
      CHECK(google::protobuf::TextFormat::ParseFromString(request_content,
                                                          &request.emplace()));
    }
    auto rpc_func = [&] (auto stopwatch, auto* duration, auto* output, absl::Notification* done) {
      {{$rpc.Name}}ExecuteImpl(*roma_service, code_token, completions, std::move(stopwatch),
                               *duration, *request);
    };
    BurstGenerator burst_gen("tg1", num_queries, burst_size, burst_cadence,
                            std::move(rpc_func));
    LOG(INFO) << "starting burst generator run."
              << "\n  burst size: " << burst_size
              << "\n  burst cadence: " << burst_cadence
              << "\n  num bursts: " << num_queries;
    const BurstGenerator::Stats stats = burst_gen.Run();
    {
      LOG(INFO) << "Shutting down Roma";
      privacy_sandbox::server_common::Stopwatch stopwatch;
      roma_service = absl::UnknownError("");
      LOG(INFO) << "Roma shutdown duration: " << stopwatch.GetElapsedTime();
    }
    LOG(INFO) << "\n  burst size: " << burst_size
              << "\n  burst cadence: " << burst_cadence
              << "\n  num bursts: " << num_queries;
    LOG(INFO) << stats.ToString();
    return;
  }
{{end}}
  LOG(FATAL) << "Unrecognized rpc '" << rpc << "'";
}
}  // namespace

int main(int argc, char** argv) {
  absl::ParseCommandLine(argc, argv);
  absl::InitializeLog();
  absl::SetStderrThreshold(absl::LogSeverity::kInfo);
  RunTrafficGenerator();
  return 0;
}
