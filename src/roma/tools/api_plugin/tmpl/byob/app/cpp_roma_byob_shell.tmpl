/**
 * This file is @generated by
 * src/roma/tools/api_plugin/tmpl/byob/app/cpp_roma_byob_shell.tmpl.
 * Do not edit.
 * Version: {{getVersion}}
 * Code Generator: {{getRomaGenerator}}
*/

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{{$file := index .Files 0}}
#include "{{$file.Name | trimSuffix (ext $file.Name)}}_roma_byob_app_service.h"

#include <fstream>
#include <iostream>
#include <istream>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/flags/flag.h"
#include "absl/flags/marshalling.h"
#include "absl/flags/parse.h"
#include "absl/flags/usage.h"
#include "absl/log/check.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/notification.h"
#include "src/communication/json_utils.h"
#include "src/roma/byob/tools/shell_evaluator.h"

ABSL_FLAG(int, num_workers, 1, "Number of workers.");
ABSL_FLAG(std::optional<std::string>, commands_file, std::nullopt,
          "Text file containing shell commands to execute.");
ABSL_FLAG(std::optional<std::string>, udf_log_file, std::nullopt,
          "Directory for storing UDF logs.");
ABSL_FLAG(privacy_sandbox::server_common::byob::Mode, sandbox,
          privacy_sandbox::server_common::byob::Mode::kModeMinimalSandbox,
          "Run BYOB with mode: gvisor, gvisor-debug, minimal.");
ABSL_FLAG(bool, syscall_filter, false, "Whether to enable syscall filtering.");


{{$svc := index $file.Services 0}}
{{- $svcopts := index $svc.Options "privacysandbox.apis.roma.app_api.v1.roma_svc_annotation"}}
{{- $svcName := printf "Byob%s" $svc.Name -}}
using {{$svcopts.CppNamespace}}::{{$svcName}};
using privacy_sandbox::server_common::byob::ShellEvaluator;

int main(int argc, char** argv) {
  absl::SetProgramUsageMessage("Opens a {{$svc.FullName}} shell.");
  absl::ParseCommandLine(argc, argv);
  const int num_workers = absl::GetFlag(FLAGS_num_workers);
  CHECK_GT(num_workers, 0) << "`num_workers` must be positive";
  std::ofstream udf_log_stream;
  if (const std::optional<std::string> udf_log_file =
          absl::GetFlag(FLAGS_udf_log_file);
      udf_log_file.has_value()) {
    udf_log_stream.open(*udf_log_file, std::ios_base::app);
  }

  // Initialize BYOB.
  absl::StatusOr<{{$svcName}}<>> service = {{$svcName}}<>::Create(
      /*config=*/{.enable_seccomp_filter = absl::GetFlag(FLAGS_syscall_filter)},
      absl::GetFlag(FLAGS_sandbox));
  CHECK_OK(service);

  // Create load and execute RPC handlers.
  auto load_fn =
      [&service, num_workers](std::string_view udf) -> absl::StatusOr<std::string> {
    return service->RegisterForLogging(udf, num_workers);
  };
  auto execute_fn = [&service, &udf_log_stream](
                        std::string_view rpc, std::string_view code_token,
                        std::string_view request_json) -> absl::StatusOr<std::string> {
{{- range $rpc := $svc.MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation"}}
  {{- $pkg := $svcopts.CppNamespace | replace "." "::" | printf "::%s" }}
  {{- $reqType := $rpc.RequestType | replace "." "::" | printf "%s::%s" $pkg }}
  {{- $respType := $rpc.ResponseType | replace "." "::" | printf "%s::%s" $pkg }}
    if (rpc == "{{$rpc.Name}}") {
      absl::Notification done;
      absl::StatusOr<std::string> json_response;
      auto request =
          ::privacy_sandbox::server_common::JsonToProto<{{$reqType}}>(
              request_json);
      if (!request.ok()) {
        return request.status();
      }
      auto callback = [&done, &json_response, &udf_log_stream](
          absl::StatusOr<{{$respType}}> response,
          absl::StatusOr<std::string_view> logs) {
        if (!response.ok()) {
          json_response = std::move(response).status();
        } else {
          json_response =
              ::privacy_sandbox::server_common::ProtoToJson<{{$respType}}>(
                  *response);
        }
        if (udf_log_stream.is_open() && logs.ok() && !logs->empty()) {
          udf_log_stream << *logs;
        }
        done.Notify();
      };
      const auto execution_token = service->{{$rpc.Name}}(
          callback, *std::move(request), /*metadata=*/{}, code_token);
      if (!execution_token.ok()) {
        return execution_token.status();
      }
      if (udf_log_stream.is_open()) {
        udf_log_stream << "Execution Token: " << execution_token->value
                       << std::endl;
      }
      done.WaitForNotification();
      return json_response;
    }
{{end}}
    return absl::InternalError(absl::StrCat("Unrecognized rpc '", rpc, "'"));
  };

  // Start repl.
  std::vector<std::string> rpcs = {
{{- range $rpc := $svc.MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation"}}
    "{{$rpc.Name}}",
{{- end}}
  };
  constexpr std::string_view kServiceSpecificMessage = R"(
{{- $rpc := index ($svc.MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation") 0 }}
     load <command> <filename>
        Load a User Defined Function (UDF). Example: load {{$rpc.Name}} /path/to/udf/example_udf

{{ $svcName }} commands:
  Usage: <rpc> <request_file> [<response_file>]
{{ range $rpc := $svc.MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation" }}
{{- $rpcopts := index $rpc.Options "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation" }}
     {{ $rpc.Name }}
{{- if and $rpcopts (len $rpcopts.Description) }}
        {{ $rpcopts.Description | wrapWith 75 "\n        " }}
{{- end }}
{{ end -}})";
  ShellEvaluator evaluator(kServiceSpecificMessage, std::move(rpcs), load_fn, execute_fn);
  if (const std::optional<std::string> commands_file =
          absl::GetFlag(FLAGS_commands_file);
      commands_file.has_value()) {
    std::ifstream ifs(*commands_file);
    if (!ifs.is_open()) {
      std::cerr << "Failed to open '" << *commands_file << "'\n";
      return -1;
    }
    std::string line;
    while (std::getline(ifs, line)) {
      switch (evaluator.EvalAndPrint(line, /*disable_commands=*/true, /*print_response=*/true)) {
        case ShellEvaluator::NextStep::kExit:
          return 0;
        case ShellEvaluator::NextStep::kError:
          return -1;
        case ShellEvaluator::NextStep::kContinue:
          continue;
      }
    }
  } else {
    std::string line;
    std::cout << "> ";
    while (std::getline(std::cin, line)) {
      switch (evaluator.EvalAndPrint(line, /*disable_commands=*/false, /*print_response=*/true)) {
        case ShellEvaluator::NextStep::kExit:
          return 0;
        case ShellEvaluator::NextStep::kError:
        case ShellEvaluator::NextStep::kContinue:
          std::cout << "> ";
          continue;
      }
    }
  }
  return 0;
}
