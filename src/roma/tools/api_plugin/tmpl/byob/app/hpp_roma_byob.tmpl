/**
 * This file is @generated by
 * src/roma/tools/api_plugin/tmpl/byob/app/hpp_roma_byob.tmpl. Do not edit.
 * Version: {{getVersion}}
 * Code Generator: {{getRomaGenerator}}
*/

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{{range $file := .Files}}
{{- $defineGuard := $file.Package | printf "%s_" | replace "." "_" | upper}}
#ifndef {{$defineGuard}}GVISOR_H_
#define {{$defineGuard}}GVISOR_H_

#include <filesystem>
#include <memory>
#include <string>
#include <string_view>
#include <utility>

#include "absl/functional/any_invocable.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "absl/synchronization/notification.h"
#include "src/roma/byob/config/config.h"
#include "src/roma/byob/interface/roma_service.h"
#include "src/roma/config/function_binding_object_v2.h"
#include "src/util/execution_token.h"
#include "src/util/status_macro/status_macros.h"
#include "{{$file.Name | trimSuffix (ext $file.Name)}}_udf_interface.pb.h"
#include "absl/time/time.h"

{{range $svc := .Services}}
{{- $svcopts := index $svc.Options "privacysandbox.apis.roma.app_api.v1.roma_svc_annotation"}}

namespace {{$svcopts.CppNamespace}} {

{{- $svcName := printf "Byob%s" $svc.Name -}}


/*
 * service: {{$svc.FullName}}
 */
template <typename TMetadata = google::scp::roma::DefaultMetadata>
class {{$svcName}} final {
 public:
  using AppService = privacy_sandbox::server_common::byob::RomaService<TMetadata>;
  using Config = privacy_sandbox::server_common::byob::Config<TMetadata>;
  using Mode = privacy_sandbox::server_common::byob::Mode;

  static absl::StatusOr<{{$svcName}}<TMetadata>> Create(Config config,
                                                        Mode mode = Mode::kModeGvisorSandbox) {
    auto roma_service = std::make_unique<AppService>();
    PS_RETURN_IF_ERROR(roma_service->Init(std::move(config), mode));
    return {{$svcName}}<TMetadata>(std::move(roma_service));
  }

  /**
   * @brief Registers a new binary synchronously from the provided `code_path`.
   *
   * @paragraph If load is successful, registered service can be called on the
   * code using the `code_token` returned by this function.
   *
   * @param code_path path to the binary to be loaded into the sandbox.
   * @param num_workers number of workers in the worker pool.
   * @return absl::StatusOr<std::string> returns the `code_token`.
   */
  absl::StatusOr<std::string> Register(std::filesystem::path code_path,
                                       int num_workers) {
    return roma_service_->LoadBinary(std::move(code_path), num_workers);
  }

  void Delete(std::string_view code_token) {
    return roma_service_->Delete(code_token);
  }

  void Cancel(google::scp::roma::ExecutionToken token) {
    return roma_service_->Cancel(std::move(token));
  }

  /**
  * @brief Creates workers for binary with logging with logging enabled.
  *
  * @paragraph If load is successful, registered service can be called on the
  * code using the `code_token` returned by this function.
  *
  * @param code_path path to the binary to be loaded into the sandbox.
  * @param num_workers number of prewarmed workers to be created.
  * Currently, zero workers are not supported.
  * @return absl::StatusOr<std::string> returns the `code_token`.
  */
  absl::StatusOr<std::string> RegisterForLogging(
      std::filesystem::path code_path, int num_workers) {
    return roma_service_->LoadBinaryForLogging(std::move(code_path), num_workers);
  }

  /**
   * @brief Registers a new binary synchronously from the provided `code_path`.
   *
   * @paragraph If load is successful, registered service can be called on the
   * code using the `code_token` returned by this function.
   *
   * @param no_log_code_token code token corresponding to the already loaded binary.
   * @param num_workers number of prewarmed workers to be created.
   * Currently, zero workers are not supported.
   * @return absl::StatusOr<std::string> returns the `code_token`.
   */
  absl::StatusOr<std::string> RegisterForLogging(
      std::string no_log_code_token, int num_workers) {
    return roma_service_->LoadBinaryForLogging(
        std::move(no_log_code_token),
        num_workers);
  }

{{- range $rpc := .MethodsWithOption "privacysandbox.apis.roma.app_api.v1.roma_rpc_annotation"}}
  {{- $pkg := $svcopts.CppNamespace | replace "." "::" | printf "::%s" }}
  {{- $reqType := $rpc.RequestType | replace "." "::" | printf "%s::%s" $pkg }}
  {{- $respType := $rpc.ResponseType | replace "." "::" | printf "%s::%s" $pkg }}
  /*
   * @brief Executes {{$rpc.Name}} referred to by the provided `code_token`
   * asynchronously.
   *
   * {{$rpc.Name}}
   * {{- $rpc.Description}}
   *
   * @param notification notifies that `response` is available.
   * @param request {{$reqType}} for the binary.
   * @param response populated with the status once execution is completed. If
   * the status is ok, then `{{$respType}}` returned by this function contains
   * the response else the error.
   * @param metadata for execution request. It is a templated type.
   * @param code_token identifier provided by load of the binary to be executed.
   * @return absl::Status
   */
  absl::StatusOr<google::scp::roma::ExecutionToken> {{$rpc.Name}}(
      absl::Notification& notification, const {{$reqType}}& request,
      absl::StatusOr<std::unique_ptr<{{$respType}}>>& response,
      TMetadata metadata = TMetadata(), std::string_view code_token = "",
      absl::Duration connection_timeout = absl::ZeroDuration()) {
    return roma_service_->ProcessRequest(
      code_token, request, std::move(metadata), connection_timeout,
      notification, response);
  }

  absl::StatusOr<google::scp::roma::ExecutionToken> {{$rpc.Name}}(
      absl::AnyInvocable<void(absl::StatusOr<{{$respType}}>,
      absl::StatusOr<std::string_view>,
      server_common::byob::ProcessRequestMetrics)> callback,
      const {{$reqType}}& request,
      TMetadata metadata = TMetadata(),
      std::string_view code_token = "",
      absl::Duration connection_timeout = absl::ZeroDuration()) {
    return roma_service_->template ProcessRequest<{{$respType}}>(
      code_token, request, std::move(metadata), connection_timeout,
      std::move(callback));
  }
{{end}}

 private:
  std::unique_ptr<AppService> roma_service_;
  explicit {{$svcName}}(std::unique_ptr<AppService> roma_service)
    : roma_service_(std::move(roma_service)) {}
};

}  // namespace {{$svcopts.CppNamespace}}
{{end}}

#endif  // {{$defineGuard}}GVISOR_H_
{{end}}
